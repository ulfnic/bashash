#!/usr/bin/env bash
# License: GNU Affero General Public License Version 3 (GNU AGPLv3), (c) 2023, Marc Gilligan <marcg@ulfnic.com>


# bashash: An exploratory project for producing rudimentary checksums in pure BASH



bashash() {
	local \
		bashash__input \
		bashash__checksum_bytes \
		output_as_var \
		end_options

	# Clear output variable to avoid false positives
	bashash__output=

	while [[ $1 ]]; do
		if [[ ! $end_options ]]; then
			case $1 in
				'--')
					end_options=1
					shift; continue ;;

				'-')
					read -d '' bashash__input
					shift; continue ;;

				'--text'|'-t')
					bashash__input=$2
					shift 2; continue ;;

				'--input-nameref'|'-n')
					local -n bashash__input=$2
					output_as_var=1
					shift 2; continue ;;

				'--output-nameref'|'-N')
					local -n bashash__output=$2
					output_as_var=1
					shift 2; continue ;;

				'--output-as-var'|'-v')
					output_as_var=1
					shift; continue ;;

				'--checksum-bytes'|'-b')
					bashash__checksum_bytes=$2
					shift 2; continue ;;

				'-'*)
					printf '%s\n' 'ERROR: bashash, unrecognized parameter: '"$1" 1>&2
					return 1
			esac
		fi

		# Parameter wasn't caught as an option, treat it as an input file
		if [[ -r $1 ]]; then
			read -d '' bashash__input < "$1"
			shift

		else
			printf '%s\n' 'ERROR: bashash, file does not exist or is not readable: '"$1" 1>&2
			return 1
		fi

	done

	# Variables are set, create checksum
	bashash__main

	# Return early if the output method is variable bashash__output, otherwise print and unset it
	[[ $output_as_var ]] && return 0

	printf '%s\n' "$bashash__output"
	unset bashash__output
}



bashash__main() {
	: ${bashash__checksum_bytes:=16}
	local \
		input_len=${#bashash__input} \
		checksum_arr=() \
		i i2 dec_int

	# Clear output variable to avoid false positives
	bashash__output=

	[[ $input_len == '0' ]] && return 1

	# Iterate through each character of the input
	for (( i = 0; i < input_len; i++ )); do

		# Convert character into a signed decimal integer
		printf -v dec_int '%d' "'${bashash__input:i:1}"

		# Prevent non-interacting values of 0
		(( dec_int++ ))

		# Additively cascade the value of dec_int through the array checksum_arr
		# using a modulo operation at each step to confine the result to 1 byte
		# and avoid arithmetic evaluation memory limits.
		checksum_arr[0]=$(( ( checksum_arr[0] + dec_int ) % 254 ))
		for (( i2 = 1; i2 < bashash__checksum_bytes; i2++ )); do
			checksum_arr[i2]=$(( ( checksum_arr[i2] + checksum_arr[i2-1] ) % 254 ))
		done
	done

	# Convert to hex
	printf -v bashash__output '%02x' "${checksum_arr[@]}"
}



# If executed directly (not sourced), pass parameters and stdin to function bashash
if [[ ${BASH_SOURCE[0]} == "${0}" ]]; then
	set -o errexit
	{ bashash "$@"; } < /dev/fd/0 || exit $?
fi



